{"meta":{"title":"fordreams1314个人博客","subtitle":"赢在格局，输在计较","description":"赢在格局，输在计较","author":"fordreams1314","url":"https://yangqinglei26.github.io","root":"/"},"pages":[{"title":"关于我","date":"2021-06-02T10:43:59.000Z","updated":"2021-06-01T10:43:59.000Z","comments":true,"path":"about/index.html","permalink":"https://yangqinglei26.github.io/about/index.html","excerpt":"","text":"姓名：杨庆雷 出生年份：90后 故乡：山西省孝义市 现居地：天津市南开区 邮箱：&#100;&#x61;&#110;&#x64;&#101;&#x74;&#x69;&#111;&#x6e;&#121;&#97;&#x6e;&#103;&#64;&#49;&#54;&#x33;&#46;&#99;&#x6f;&#109;"},{"title":"categories","date":"2021-05-31T03:55:19.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"categories/index.html","permalink":"https://yangqinglei26.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-31T03:56:05.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"tags/index.html","permalink":"https://yangqinglei26.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"nginx","slug":"java/nginx","date":"2022-07-07T02:24:06.000Z","updated":"2022-07-07T11:24:06.000Z","comments":true,"path":"2022/07/07/java/nginx/","link":"","permalink":"https://yangqinglei26.github.io/2022/07/07/java/nginx/","excerpt":"","text":"http2万字 让你全面认识 Nginx，收藏 ！ 超详细的Nginx负载均衡+高可用配置 史上讲解最好的Nginx 教程，从入门到精通 location路径映射： 精确匹配 前缀匹配 正则匹配 1234567891011121314151617181920212223242526272829303132333435363738394041# rewrite /yang/(.*) /$1;-----------------------------------location /yang &#123; proxy_pass http://node/; #proxy_set_header Host $http_host; #proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #root /usr/share/nginx/html; #index index.html index.htm;ß&#125;------------------------------------server &#123; listen 8081; server_name localhost; location /yang/ &#123; alias /home/yang/e1/;# 访问http://101.200.208.190/yang/index3.html，实际在服务器找的路径 是/home/yang/e1/index3.html index index.html index.htm; &#125;&#125;server &#123; listen 8082; server_name localhost; location /yang &#123; alias /home/yang/e2/;# 访问http://101.200.208.190/yang/index3.html，实际在服务器找的路径是/home/yang/e1//index3.html index index.html index.htm; &#125;&#125;server &#123; listen 8083; server_name localhost; location /yang &#123; alias /home/yang/e3/; index index.html index.htm; &#125;&#125;upstream node &#123; server localhost:8081; server localhost:8082; server localhost:8083;&#125;","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"服务器","slug":"java/服务器","permalink":"https://yangqinglei26.github.io/categories/java/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"服务器","slug":"服务器","permalink":"https://yangqinglei26.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"https://yangqinglei26.github.io/tags/nginx/"}]},{"title":"知识架构图","slug":"java/知识架构图","date":"2021-09-17T07:30:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/09/17/java/知识架构图/","link":"","permalink":"https://yangqinglei26.github.io/2021/09/17/java/%E7%9F%A5%E8%AF%86%E6%9E%B6%E6%9E%84%E5%9B%BE/","excerpt":"","text":"后台知识架构图","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"}]},{"title":"idea相关使用","slug":"java/idea","date":"2021-09-13T08:30:06.000Z","updated":"2022-08-02T09:14:32.368Z","comments":true,"path":"2021/09/13/java/idea/","link":"","permalink":"https://yangqinglei26.github.io/2021/09/13/java/idea/","excerpt":"","text":"配置注释123456789101112131415161718192021/** * @author yql * @date $&#123;DATE&#125; * @desc */- 类注释/** * @author yql * @date $DATE$ * @desc */- 方法注释/** * @author yql * @date $DATE$ * @desc $params$ * @return $return$ */ 1groovyScript(&quot;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;result+=&#x27;* @param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\\\r\\\\n&#x27; : &#x27;&#x27;)&#125;; return result&quot;, methodParameters()) 1groovyScript(&quot;def result=&#x27;&#x27;; def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;&lt;&#x27;).toList(); for(i = 0; i &lt; params.size(); i++) &#123;if(i!=0)&#123;result+=&#x27;&lt;&#x27;;&#125;; def p1=params[i].split(&#x27;,&#x27;).toList(); for(i2 = 0; i2 &lt; p1.size(); i2++) &#123; def p2=p1[i2].split(&#x27;\\\\\\\\.&#x27;).toList(); result+=p2[p2.size()-1]; if(i2!=p1.size()-1)&#123;result+=&#x27;,&#x27;&#125; &#125; ; &#125;; return result&quot;, methodReturnType())","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"}]},{"title":"Mybatis","slug":"java/Mybatis","date":"2021-07-05T11:24:06.000Z","updated":"2022-08-02T09:14:32.348Z","comments":true,"path":"2021/07/05/java/Mybatis/","link":"","permalink":"https://yangqinglei26.github.io/2021/07/05/java/Mybatis/","excerpt":"","text":"入门 mybatis中的一级缓存和二级缓存 MyBatis一级缓存详解 MyBatis 二级缓存全详解 面试相关","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"https://yangqinglei26.github.io/categories/java/Mybatis/"},{"name":"数据库","slug":"java/Mybatis/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mybatis/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yangqinglei26.github.io/tags/Mybatis/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"网络相关","slug":"java/网络相关","date":"2021-06-30T07:30:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/30/java/网络相关/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/30/java/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/","excerpt":"","text":"socket原理 单服务器最大tcp连接数及调优汇总 分析单机最大长连接数","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"网络相关","slug":"java/网络相关","permalink":"https://yangqinglei26.github.io/categories/java/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"网络相关","slug":"网络相关","permalink":"https://yangqinglei26.github.io/tags/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"}]},{"title":"zookeeper","slug":"java/zookeeper","date":"2021-06-30T00:30:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/30/java/zookeeper/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/30/java/zookeeper/","excerpt":"","text":"基础 进阶 使用 基于zookeeper实现统一配置管理 ZooKeeper 实现命名服务 基于ZooKeeper Curator实现分布式锁 基础 分布式锁之Zookeeper ZAB协议 面试相关","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"zookeeper","slug":"java/zookeeper","permalink":"https://yangqinglei26.github.io/categories/java/zookeeper/"},{"name":"分布式","slug":"java/zookeeper/分布式","permalink":"https://yangqinglei26.github.io/categories/java/zookeeper/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://yangqinglei26.github.io/tags/zookeeper/"},{"name":"分布式","slug":"分布式","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"Linux相关","slug":"java/Linux","date":"2021-06-29T11:24:06.000Z","updated":"2022-08-02T09:14:32.348Z","comments":true,"path":"2021/06/29/java/Linux/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/29/java/Linux/","excerpt":"","text":"1. 常用命令12345df -h # 查看硬盘使用less -iN #查看文件内容ls |grep -v &quot;tmp*&quot; #查找不包含tmp*的内容cp –r # 复制目录下的所有文件 2. 基础组件安装 telnet 安装 jdk8 安装","categories":[{"name":"linux","slug":"linux","permalink":"https://yangqinglei26.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://yangqinglei26.github.io/tags/linux/"}]},{"title":"分布式相关","slug":"java/分布式","date":"2021-06-29T11:24:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/29/java/分布式/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/29/java/%E5%88%86%E5%B8%83%E5%BC%8F/","excerpt":"","text":"分布式相关 分布式锁1 分布式锁2 分布式锁3 分布式锁 导航 分布式id 分布式id导航 Leaf：美团分布式ID生成服务开源 柔性事务 ：TCC两阶段补偿型 分布式事务","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"分布式","slug":"java/分布式","permalink":"https://yangqinglei26.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"分布式","slug":"分布式","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"}]},{"title":"ELK","slug":"java/ELK","date":"2021-06-20T11:24:06.000Z","updated":"2022-08-02T09:14:32.312Z","comments":true,"path":"2021/06/20/java/ELK/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/20/java/ELK/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"nosql","slug":"java/nosql","permalink":"https://yangqinglei26.github.io/categories/java/nosql/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"elk","slug":"elk","permalink":"https://yangqinglei26.github.io/tags/elk/"},{"name":"nosql","slug":"nosql","permalink":"https://yangqinglei26.github.io/tags/nosql/"}]},{"title":"Docker","slug":"java/Docker","date":"2021-06-17T11:24:06.000Z","updated":"2022-08-02T09:14:32.312Z","comments":true,"path":"2021/06/17/java/Docker/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/17/java/Docker/","excerpt":"","text":"常用命令1 安装nginxDocker 安装 Nginx 容器 (完整详细版)","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"运维","slug":"java/运维","permalink":"https://yangqinglei26.github.io/categories/java/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"docker","slug":"docker","permalink":"https://yangqinglei26.github.io/tags/docker/"},{"name":"运维","slug":"运维","permalink":"https://yangqinglei26.github.io/tags/%E8%BF%90%E7%BB%B4/"}]},{"title":"SpringCloud","slug":"java/SpringCloud","date":"2021-06-15T11:24:06.000Z","updated":"2022-08-02T09:14:32.352Z","comments":true,"path":"2021/06/15/java/SpringCloud/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/15/java/SpringCloud/","excerpt":"","text":"cloud1 cloud2 api网关","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://yangqinglei26.github.io/categories/java/spring/"},{"name":"springcloud","slug":"java/spring/springcloud","permalink":"https://yangqinglei26.github.io/categories/java/spring/springcloud/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yangqinglei26.github.io/tags/spring/"},{"name":"springcloud","slug":"springcloud","permalink":"https://yangqinglei26.github.io/tags/springcloud/"}]},{"title":"Activiti","slug":"java/Activiti","date":"2021-06-13T11:24:06.000Z","updated":"2022-08-02T09:14:32.312Z","comments":true,"path":"2021/06/13/java/Activiti/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/13/java/Activiti/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"工作流","slug":"java/工作流","permalink":"https://yangqinglei26.github.io/categories/java/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"activiti","slug":"activiti","permalink":"https://yangqinglei26.github.io/tags/activiti/"},{"name":"工作流","slug":"工作流","permalink":"https://yangqinglei26.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"}]},{"title":"RabbitMQ","slug":"java/RabbitMQ","date":"2021-06-11T11:24:06.000Z","updated":"2022-08-02T09:14:32.352Z","comments":true,"path":"2021/06/11/java/RabbitMQ/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/11/java/RabbitMQ/","excerpt":"","text":"1. 消息中间件1.1. 使用场景 购票 秒杀 1.2. 作用 销峰限流 应用解耦 分布式事务 基于RocketMQ的分布式事务解决方案 RocketMQ实现分布式事务原理","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"消息队列","slug":"java/消息队列","permalink":"https://yangqinglei26.github.io/categories/java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"消息队列","slug":"消息队列","permalink":"https://yangqinglei26.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://yangqinglei26.github.io/tags/rabbitmq/"}]},{"title":"Redis","slug":"java/Redis","date":"2021-06-10T11:24:06.000Z","updated":"2022-08-02T09:14:32.352Z","comments":true,"path":"2021/06/10/java/Redis/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/10/java/Redis/","excerpt":"","text":"基础教程 操作 基本数据类型底层实现 基础框架 知识点 进阶1 进阶2 进阶3 进阶4 一致性hash算法 redis cluster1 redis cluster2 缓存穿透 分布式锁 跳跃表 红黑树 Redis与Mysql双写一致性方案解析 1. 安装2. 基本命令3. 数据类型（5+3） Redis的底层数据结构 Redis的五大数据类型的底层实现 string sds list ziplist linkedlist set intset hashtable zset ziplist skiplist hash ziplist hashtable 4. 高级特性4.1. 发布和订阅4.2. 管道技术4.3. Stream5. 事务6. 内存回收6.1. 过期策略 定时过期 惰性过期 定期过期 6.2. 淘汰策略 lru volatile-lru -&gt; Evict using approximated LRU, only keys with an expire set. allkeys-lru -&gt; Evict any key using approximated LRU. lfu volatile-lfu -&gt; Evict using approximated LFU, only keys with an expire set. allkeys-lfu -&gt; Evict any key using approximated LFU. random volatile-random -&gt; Remove a random key having an expire set. allkeys-random -&gt; Remove a random key, any key. noeviction -&gt; Don’t evict anything, just return an error on write operations. volatile-ttl -&gt; Remove the key with the nearest expire time (minor TTL) 7. 持久化8. 集群8.1. 主从复制 主节点 redis.conf 123456bind * -::*port 6379daemonize yespidfile /usr/local/bin/redisconfigs/redis-6379/redis.pidlogfile &quot;/usr/local/bin/redisconfigs/redis-6379/redis.log&quot;dir /usr/local/bin/redisconfigs/redis-6379 从节点 redis.conf 12345port 6381daemonize yespidfile /usr/local/bin/redisconfigs/redis-6381/redis.pidlogfile &quot;/usr/local/bin/redisconfigs/redis-6381/redis.log&quot;dir /usr/local/bin/redisconfigs/redis-6381 12# 查看主从信息redis-cli -p 6381 info replication 8.2. 主从+哨兵12345port 26379pidfile /usr/local/bin/redisconfigs/sentinel-26379/redis-sentinel.pidlogfile &quot;/usr/local/bin/redisconfigs/sentinel-26379/redis-sentinel.log&quot;dir /usr/local/bin/redisconfigs/sentinel-26379sentinel monitor mymaster 127.0.0.1 6379 2 12# 查看哨兵信息redis-cli -p 26379 info 8.3. redis cluster面试相关","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"缓存","slug":"java/缓存","permalink":"https://yangqinglei26.github.io/categories/java/%E7%BC%93%E5%AD%98/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"redis","slug":"redis","permalink":"https://yangqinglei26.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"https://yangqinglei26.github.io/tags/%E7%BC%93%E5%AD%98/"}]},{"title":"SpringBoot","slug":"java/springboot","date":"2021-06-09T11:24:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/09/java/springboot/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/09/java/springboot/","excerpt":"","text":"基础","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://yangqinglei26.github.io/categories/java/spring/"},{"name":"springboot","slug":"java/spring/springboot","permalink":"https://yangqinglei26.github.io/categories/java/spring/springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yangqinglei26.github.io/tags/spring/"},{"name":"springboot","slug":"springboot","permalink":"https://yangqinglei26.github.io/tags/springboot/"}]},{"title":"Spring","slug":"java/spring","date":"2021-06-08T11:24:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/08/java/spring/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/08/java/spring/","excerpt":"","text":"spring IOC Spring IOC 容器源码分析 bean的注解 @Component @Controller @Service @Repository @Bean 作用于方法 bean的作用域 singleton prototype request session bean的生命周期 SpringBean生命周期详解 Spring Bean的生命周期 beandefinition —&gt; BeanFactoryPostProcessor.postProcessBeanFactory() 修改beandefinition —&gt; InstantiationAwareBeanPostProcessorAdapter .postProcessBeforeInstantiation() —&gt; 实例化 —&gt;InstantiationAwareBeanPostProcessorAdapter .postProcessAfterInstantiation() —&gt; InstantiationAwareBeanPostProcessorAdapter .postProcessProperties() 修改property —&gt; 配置property —&gt; 检查aware接口并设置相关依赖 —&gt; init() —&gt; destroy() 单例bean的线程安全 ThreadLocale prototype AOP JDK动态代理 动态代理与静态代理区别 AspectJ的使用方法 Spring AOP和AspectJ的区别是什么？ spring mvcspring 事务 事务相关 一口气说出 6种 @Transactional 注解失效场景 @Transactional 的常用配置参数总结（只列巨额 5 个我平时比较常用的）： 属性名 说明 propagation 事务的传播行为，默认值为 REQUIRED，可选的值在上面介绍过 isolation 事务的隔离级别，默认值采用 DEFAULT，可选的值在上面介绍过 timeout 事务的超时时间，默认值为-1（不会超时）。如果超过该时间限制但事务还没有完成，则自动回滚事务。 readOnly 指定事务是否为只读事务，默认值为 false。 rollbackFor 用于指定能够触发事务回滚的异常类型，并且可以指定多个异常类型。 @Transactional的使用注意事项总结 @Transactional 注解只有作用到 public 方法上事务才生效，不推荐在接口上使用； 避免同一个类中调用 @Transactional 注解的方法，这样会导致事务失效； 正确的设置 @Transactional 的 rollbackFor 和 propagation 属性，否则事务可能会回滚失败 spring 设计模式 设计模式 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 循环依赖 循环依赖的解决 Spring 是如何解决循环依赖的 核心 循环依赖问题解决方法很多，主要有： 使用@Lazy注解，延迟加载 使用@DependsOn注解，指定加载先后关系 修改文件名称，改变循环依赖类的加载顺序","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"spring","slug":"java/spring","permalink":"https://yangqinglei26.github.io/categories/java/spring/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"spring","slug":"spring","permalink":"https://yangqinglei26.github.io/tags/spring/"}]},{"title":"ShardingSphere","slug":"java/ShardingSphere","date":"2021-06-07T11:24:06.000Z","updated":"2022-08-02T09:14:32.352Z","comments":true,"path":"2021/06/07/java/ShardingSphere/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/07/java/ShardingSphere/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"数据库","slug":"java/数据库","permalink":"https://yangqinglei26.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式数据处理","slug":"java/数据库/分布式数据处理","permalink":"https://yangqinglei26.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式数据处理","slug":"分布式数据处理","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"ShardingSphere","slug":"ShardingSphere","permalink":"https://yangqinglei26.github.io/tags/ShardingSphere/"}]},{"title":"Mycat","slug":"java/Mycat","date":"2021-06-05T11:24:06.000Z","updated":"2022-08-02T09:14:32.348Z","comments":true,"path":"2021/06/05/java/Mycat/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/05/java/Mycat/","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"Mycat","slug":"java/Mycat","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/"},{"name":"数据库","slug":"java/Mycat/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式数据处理","slug":"java/Mycat/数据库/分布式数据处理","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mycat","slug":"Mycat","permalink":"https://yangqinglei26.github.io/tags/Mycat/"},{"name":"分布式数据处理","slug":"分布式数据处理","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"}]},{"title":"Mysql","slug":"java/Mysql","date":"2021-06-04T11:24:06.000Z","updated":"2022-08-02T09:14:32.348Z","comments":true,"path":"2021/06/04/java/Mysql/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/04/java/Mysql/","excerpt":"","text":"基础 MySQL 三万字精华总结 两阶段提交 执行过程 Innodb进阶 mysql实战 安装库存储引擎编码设置表三范式建表规约主从复制分库分表查询监控查询优化索引索引分类 覆盖索引 最左匹配 索引下推： ​ 索引查询级别为range时，才会触发索引下推 索引规约索引优化事务两阶段提交 执行过程 Double Write 日志详细分析MySQL事务日志(redo log和undo log) Mysql 重做日志 MySQL中的redolog的作用 mysql redo日志与刷脏 缓冲池缓冲池(buffer pool) MySQL InnoDB Buffer Pool MVCCMySQL中MVCC的正确打开方式 正确的理解MySQL的MVCC及实现原理 MySQL的ReadView 窗口函数withWITH recursive使用 123456789-- 递归查询所有二级部门下的子部门WITH recursive temp AS( SELECT dept_logic_id,dept_name,dept_logic_id as parentId FROM bams_dept WHERE parent_logic_id=&#x27;0001&#x27; UNION ALL SELECT u.dept_logic_id,u.dept_name,t.parentId FROM bams_dept u,temp t WHERE u.parent_logic_id=t.dept_logic_id),temp2 as (select parentId,group_concat(dept_logic_id) from temp GROUP BY parentId)select * from temp2; 数据批量删除后优化 innodb 1234-- 查询表空间show table status like &#x27;scene_qrcode_scan_log&#x27;;-- 优化ANALYZE TABLE scene_qrcode_scan_log; myisam 1OPTIMIZE TABLE scene_qrcode_scan_log_20220602; rowid掌握mysql隐藏字段(rowid)什么时候是可见的","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"Mysql","slug":"java/Mysql","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/"},{"name":"数据库","slug":"java/Mysql/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"Mysql","permalink":"https://yangqinglei26.github.io/tags/Mysql/"}]},{"title":"Mysql","slug":"java/postgre","date":"2021-06-04T11:24:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/04/java/postgre/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/04/java/postgre/","excerpt":"","text":"操作手册 分区窗口函数withWITH查询 1","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"Mysql","slug":"java/Mysql","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/"},{"name":"数据库","slug":"java/Mysql/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Mysql","slug":"Mysql","permalink":"https://yangqinglei26.github.io/tags/Mysql/"}]},{"title":"23种设计模式","slug":"java/23种设计模式","date":"2021-06-02T11:24:06.000Z","updated":"2022-08-02T09:14:32.312Z","comments":true,"path":"2021/06/02/java/23种设计模式/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/02/java/23%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"参考资料1 模板模式 模板模式 外观模式 外观模式 单例模式 桥接模式 适配器模式 策略模式 设计模式之策略模式 建造者模式 设计模式之装饰者模式 简单工厂 工厂方法 抽象工厂 观察者 1. 设计模式概述1.1. 设计模式的本质 这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解。 软件设计模式只是一个引导，在实际的软件开发中，必须根据具体的需求来选择： 对于简单的程序，可能写一个简单的算法要比引入某种设计模式更加容易； 但是对于大型项目开发或者框架设计，用设计模式来组织代码显然更好。 设计模式并不是 Java 的专利，它同样适用于 C++、C#、JavaScript 等其它面向对象的编程语言。 1.2. 学习设计模式的意义 可以提高程序员的思维能力、编程能力和设计能力。 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。 1.3. 设计模式分类设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分。 1.3.1. 根据目的来分根据模式是用来完成什么工作来划分，这种方式可分为创建型模式、结构型模式和行为型模式 3 种。 创建型模式：用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。 结构型模式：用于描述如何将类或对象按某种布局组成更大的结构，GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。 行为型模式：用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。 1.3.2. 根据作用范围来分根据模式是主要用于类上还是主要用于对象上来分，这种方式可分为类模式和对象模式两种。 类模式：用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、（类）适配器、模板方法、解释器属于该模式。 对象模式：用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式。 表 1 介绍了这 23 种设计模式的分类。 范围\\目的 创建型模式 结构型模式 行为型模式 类模式 工厂方法 (类）适配器 模板方法、解释器 对象模式 单例 原型 抽象工厂 建造者 代理 (对象）适配器 桥接 装饰 外观 享元 组合 策略 命令 职责链 状态 观察者 中介者 迭代器 访问者 备忘录 1.3.3. GoF的23种设计模式的功能前面说明了 GoF 的 23 种设计模式的分类，现在对各个模式的功能进行介绍。 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。 工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。 装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。 模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。 2. 软件设计七大原则2.1. 开闭原则2.1.1. 定义对扩展开放，对修改关闭。当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。 2.1.2. 作用开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。具体来说，其作用如下。 对软件测试的影响 软件遵守开闭原则的话，软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。 可以提高代码的可复用性 粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。 可以提高软件的可维护性 遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。 2.1.3. 实现方法可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。 因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。 案例 文件上传分3部分：保存文件、解析文件、数据入库。我们可以抽象这个动作，实现对不同类型文件的上传,同时我们可以扩展来实现对不同类型文件的解析。 2.2. 里氏替换原则 解释了继承的职责和能力范围 2.2.1. 定义里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 2.2.2. 作用里氏替换原则的主要作用如下： 里氏替换原则是实现开闭原则的重要方式之一。 它克服了继承中重写父类造成的可复用性变差的缺点。 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。 加强程序的健壮性，同时变更时可以做到非常好的兼容性，提高程序的维护性、可扩展性，降低需求变更时引入的风险。 2.2.3. 实现方法根据上述理解，对里氏替换原则的定义可以总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等 总结：入口松，出口紧 通过重写父类的方法来完成新的功能写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。 如果程序违背了里氏替换原则，则继承类的对象在基类出现的地方会出现运行错误。这时其修正方法是：取消原来的继承关系，重新设计它们之间的关系。 案例： “几维鸟不是鸟”，“正方形不是长方形”都是不遵守里氏替换原则的经典案例 2.3. 依赖倒置原则 指出了抽象的重要性 2.3.1. 定义依赖倒置原则的原始定义为：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。 依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。 由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。 使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。 2.3.2. 作用依赖倒置原则的主要作用如下。 依赖倒置原则可以降低类间的耦合性。 依赖倒置原则可以提高系统的稳定性。 依赖倒置原则可以减少并行开发引起的风险。 依赖倒置原则可以提高代码的可读性和可维护性。 2.3.3. 实现方法依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。 每个类尽量提供接口或抽象类，或者两者都具备。 变量的声明类型尽量是接口或者是抽象类。 任何类都不应该从具体类派生。 使用继承时尽量遵循里氏替换原则。 总结：面向接口编程 2.4. 单一职责原则2.4.1. 定义单一职责原则又称单一功能原则，这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。 该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点： 一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力； 当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。 2.4.2. 作用单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。 降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。 提高类的可读性。复杂性降低，自然其可读性会提高。 提高系统的可维护性。可读性提高，那自然更容易维护了。 变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。 2.4.3. 实现方法单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 2.5. 接口隔离原则2.5.1. 定义接口隔离原则要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。 接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的： 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。 2.5.2. 作用接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。 将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。 接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。 如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。 使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。 能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。 2.5.3. 实现方法在具体应用接口隔离原则时，应该根据以下几个规则来衡量。 接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。 为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。 了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。 提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。 2.6. 迪米特法则2.6.1. 定义迪米特法则指如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。 2.6.2. 作用迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。 降低了类之间的耦合度，提高了模块的相对独立性。 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。 但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。 2.6.3. 实现方法从迪米特法则的定义和特点可知，它强调以下两点： 从依赖者的角度来说，只依赖应该依赖的对象。 从被依赖者的角度说，只暴露应该暴露的方法。 所以，在运用迪米特法则时要注意以下 6 点。 在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。 在类的结构设计上，尽量降低类成员的访问权限。 在类的设计上，优先考虑将一个类设置成不变类。 在对其他类的引用上，将引用其他对象的次数降到最低。 不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。 谨慎使用序列化（Serializable）功能。 2.7. 合成复用原则 通过对象引用，来调用已有对象功能 2.7.1. 定义合成复用原则要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。 2.7.2. 作用通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。 继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。 子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。 它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。 采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。 它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。 新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。 复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。 2.7.3. 实现方法合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"设计模式","slug":"java/设计模式","permalink":"https://yangqinglei26.github.io/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yangqinglei26.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"联盟","slug":"manage/联盟","date":"2021-06-02T10:43:59.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/02/manage/联盟/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/02/manage/%E8%81%94%E7%9B%9F/","excerpt":"","text":"","categories":[{"name":"管理","slug":"管理","permalink":"https://yangqinglei26.github.io/categories/%E7%AE%A1%E7%90%86/"}],"tags":[{"name":"管理","slug":"管理","permalink":"https://yangqinglei26.github.io/tags/%E7%AE%A1%E7%90%86/"}]},{"title":"买车","slug":"life/买车","date":"2021-06-01T10:43:59.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/06/01/life/买车/","link":"","permalink":"https://yangqinglei26.github.io/2021/06/01/life/%E4%B9%B0%E8%BD%A6/","excerpt":"","text":"","categories":[{"name":"生活","slug":"生活","permalink":"https://yangqinglei26.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"买车","slug":"买车","permalink":"https://yangqinglei26.github.io/tags/%E4%B9%B0%E8%BD%A6/"},{"name":"生活","slug":"生活","permalink":"https://yangqinglei26.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"hexo使用","slug":"java/hexo","date":"2021-05-31T11:24:06.000Z","updated":"2021-06-01T11:24:06.000Z","comments":true,"path":"2021/05/31/java/hexo/","link":"","permalink":"https://yangqinglei26.github.io/2021/05/31/java/hexo/","excerpt":"","text":"官方文档 1. 依赖环境（windows） 安装git 安装node 2. 安装2.1. 安装客户端并初始化工作目录12345# 全局安装hexo客户端npm install -g hexo-cli# 初始化目录结构cd &lt;folder&gt;hexo init 2.2. 安装服务并启动12345# 进入工作目录，安装 hexo-server 服务依赖npm install hexo-server --save# 启动hexo，默认端口 4000 # hexo server -p &lt;端口号&gt;hexo server 输入 http://localhost:3000 ，测试是否部署成功： 3. 发布到Github3.1. 配置SSH 参考资料：Git 3.2. 将文件发布到github3.2.1. 安装部署依赖12# 进入工作目录npm install hexo-deployer-git --save 3.2.2. 修改配置 修改工作目录下的 _config.yml： 12345deploy: type: git repo: &lt;repository url&gt; #https://bitbucket.org/JohnSmith/johnsmith.bitbucket.io branch: [branch] message: [message] 3.2.3. 测试是否成功123456# 清空缓存和publc目录hexo clean# 生成静态yemhexo generate# 部署到githexo deploy 登陆github，查看是否提交成功 3.3. 设置GitHub Pages 修改根url 重新部署 123hexo cleanhexo generatehexo deploy 4. 切换主题 主题 ayer主题使用 （说明： 由于我们会对主题进行二次开发，所以建议使用文中第2种方法进行安装） 4.1. 安装主题12cd &lt;folder&gt;git clone https://github.com/Shen-Yu/hexo-theme-ayer.git themes/ayer 修改工作目录下 _config.yml 修改语言为中文 4.2. 安装插件12# 搜索插件npm install hexo-generator-searchdb --save 修改工作目录下 _config.yml 12345# hexo-generator-searchdbsearch: path: search.xml field: post format: html 4.3. 生成分类和标签页1234# 生成分类页hexo new page categories# 生成标签页hexo new page tags 然后将以下内容追加到 /source/categories/index.md 文件 12type: &quot;categories&quot;layout: &quot;categories&quot; 然后将以下内容追加到 /source/tags/index.md 文件 12type: &quot;tags&quot;layout: &quot;tags&quot; 4.4. 配置gittalk 参考 此url与Git page提供的url保持一致 4.4. 修改主题配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252# 侧边栏菜单menu: 主页: / 归档: /archives 分类: /categories 标签: /tags 关于我: /2019/about# 站点次标题和打字动效# https://github.com/mattboldt/typed.jssubtitle: enable: true # 是否开启动效 text: 赢在格局，输在计较 # 显示的文字 text2: # 滚动播放，如果不需要可以留空 text3: # 最多支持三段文字 startDelay: 0 # 延迟时间 typeSpeed: 200 # 打字速度 loop: false # 是否循环 backSpeed: 100 # 回退速度 showCursor: true # 是否显示光标# 网站图标和侧边栏logofavicon: /favicon.icologo: /images/face.jpg# 封面配置# enable-是否启用封面；path-封面背景图；logo-封面logocover: enable: false path: /images/cover1.jpg # /source/images目录下附送多张美图，可更换 logo: true #/images/ayer.svg，如果不要直接设置成false# 页面顶部进度条progressBar: true# 告示板模块broadcast: enable: true # true开启，false关闭 type: 2 # 1：自定义输入，2：一言api(https://hitokoto.cn/) text: 一个安静优雅的hexo主题，快速且响应式。 # type为1时有效# 文章配置# 文章太长，截断按钮文字(在需要截断的行增加此标记：&lt;!--more--&gt;)excerpt_link: 阅读更多...# 如果你嫌每篇文章手动加more标记比较麻烦，又不想在首页全文显示，可以把excerpt_all设置成true，这样首页只会显示文章归档excerpt_all: false# 是否开启代码复制按钮copy_btn: true# 是否开启文章分享按钮share_enable: false# 国内的社交平台(If you are not in China, maybe you prefer to set:false)share_china: true# 文章分享文字share_text: 分享# 分页文字nav_text: page_prev: 上一页 page_next: 下一页 post_prev: 上一篇 post_next: 下一篇# 文章页是否显示目录toc: true# 文章中的图片是否支持点击放大image_viewer: true# https://github.com/willin/hexo-wordcount# 是否开启字数统计(关闭请设置enable为false)# 也可以单独在md文件里Front-matter设置`no_word_count: true`属性，来自定义关闭字数统计word_count: enable: true # 只在文章详情显示(不在首页显示) only_article_visit: true# 打赏# 打赏type设定：0-关闭打赏； 1-文章对应的md文件里有reward:true属性，才有打赏； 2-所有文章均有打赏reward_type: 0# 打赏wordingreward_wording: &quot;请我喝杯咖啡吧~&quot;# 支付宝二维码图片地址，跟你设置logo的方式一样。比如：/images/alipay.jpgalipay: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg# 微信二维码图片地址weixin: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg# 版权声明# 版权声明type设定：0-关闭版权声明； 1-文章对应的md文件里有copyright: true属性，才有版权声明； 2-所有文章均有版权声明copyright_type: 2# 是否启用搜索# 需要安装hexo-generator-searchdb(https://github.com/theme-next/hexo-generator-searchdb)search: true# RSS订阅(先安装hexo-generator-feed插件，再去博客根目录config进行配置)# 不想显示可以直接留空rss: # 是否启用黑夜模式开关darkmode: true# 动态背景效果: 0-关闭，1-动态线条(跟随鼠标)canvas_bg: 0# 自定义鼠标样式，直接替换/images/mouse.cur文件mouse: enable: false path: /images/mouse.cur# 鼠标点击效果：0-关闭，1-爱心，2-爆炸烟花，3-粒子烟花click_effect: 0# 页面宽度自定义（不建议修改，可能造成布局混乱），article_width文章宽度，sidebar_width侧边栏宽度layout: article_width: 80rem sidebar_width: 8rem# GitHub Ribbons-封面右上角的forkme，换样式直接在source/images目录下替换forkme图片github: # (关闭请设置为false) enable: false url: https://github.com/Shen-Yu/hexo-theme-ayer# 网易云音乐插件music: enable: false # 播放器尺寸类型(1：小尺寸、2：大尺寸) type: 1 id: 22707008 # 网易云分享的音乐ID(更换音乐请更改此配置项) autoPlay: true # 是否开启自动播放# 访问量统计(不蒜子)busuanzi: enable: true# 友盟cnzz统计(url填js代码src链接)cnzz: enable: false url: https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914# Google Analyticsgoogle_analytics: &quot;&quot;# 百度统计baidu_analytics: &quot;awwssw1snsnsnn1ndndnndnd99j&quot;# Mathjax数学公式mathjax: false# Katex数学公式(allpost设置为false时只有头部设置math:true的文章才开启)# 需要更换hexo渲染器，npm un hexo-renderer-marked -S &amp;&amp; npm i hexo-renderer-markdown-it-katex -Skatex: enable: false # true allpost: true copy_tex: false# mermaid流程图 三个选项缺一不可(https://mermaid-js.github.io/mermaid/)mermaid: enable: false cdn: https://cdn.jsdelivr.net/npm/mermaid@8.9.2/dist/mermaid.min.js theme: forest# 网站成立年份(默认为 2019，若填入年份小于当前年份，则显示为 2018-2019 类似的格式)since: 2020# 是否显示页脚信息(建议保留)pageFooter: false# ICP备案信息尾部显示icp: enable: false url: &quot;http://www.beian.miit.gov.cn/&quot; # 备案链接 text: &quot;浙ICP备88888888&quot; # 备案信息# 公安备案信息尾部显示gongan: enable: false img: /images/beian.png #公安备案图片 url: &quot;http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=01234567890123&quot; #公安备案链接 text: &quot;浙公网安备01234567890123号&quot; #公安备案信息# 友情链接friends_link: Ayer主题: #网站名称 #网站地址 url: https://github.com/Shen-Yu/hexo-theme-ayer #网站图片(可忽略不写) img: /images/ayer.png GitHub: url: https://github.com/Shen-Yu img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/github.png 码云: url: https://gitee.com/shen-yu img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/gitee.png Hexo官网: url: https://hexo.io img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/hexo.png Hexo图表插件: url: https://github.com/Shen-Yu/hexo-tag-chart img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/hexo-tag-chart.png# 评论：1、Valine(推荐)；2、Gitalk；3、Twikoo; 4.MiniValine# 1、Valine[一款快速、简洁且高效的无后端评论系统](https://github.com/xCss/Valine)# 启用Valine必须先创建leancloud应用， 获取 id|key 填入即可leancloud: enable: false app_id: # app_key: ## Valine配置valine: enable: true # 是否启用 avatar: monsterid # 头像样式(https://valine.js.org/avatar.html) placeholder: 给我的文章加点评论吧~ # placeholder# 2、Gitalk(https://github.com/gitalk/gitalk)gitalk: enable: true # true clientID: 129f2c758bba8433d4c8 # GitHub Application Client ID clientSecret: eeb34f70e9dfcf7e04e8d9a9206136315394f8c1 # Client Secret repo: yangtest # Repository name owner: yangqinglei26 # GitHub ID admin: yangqinglei26 # GitHub ID# 3、Twikoo(https://github.com/imaegoo/twikoo)twikoo: enable: false envId: ## 4、MiniValine# See: https://github.com/MiniValine/MiniValineminivaline: enable: false # 更多选项 https://minivaline.js.org/docs/cn/#/Options 按照yml格式继续填写即可 （除了 [el] 选项） # emoticonUrl 等列表选项 可参考 https://github.com/MiniValine/hexo-next-minivaline # 下面是一个例子： serverURL: https://minivaline.your-domain.com# 首页广告配置# 可以根据需要自行增加ad_3，ad_4...，留空则不显示，建议图片和url不要带ad等关键词，否则可能会被adblock等插件屏蔽# ads:# ad_1:# title: 腾讯云限时秒杀# img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_1.jpg# url: https://curl.qcloud.com/ezctH6FU# width: 300# ad_2:# title: 云服务器全球购低至2折# img: https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/ten_2.jpg# url: https://curl.qcloud.com/kvO7hb43# width: 300 4.5. 部署并测试1234# 清空缓存 hexo clean# 生成public文件并部署到githubhexo g -d 访问 https://yangqinglei26.github.io/yangtest 5. 解决图片展示问题5.1. 安装图片处理插件12cd &lt;工作目录&gt;npm install hexo-asset-image --save 5.2. 修改插件文件 /node_modules/hexo-asset-image/index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x27;use strict&#x27;;var cheerio = require(&#x27;cheerio&#x27;);// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split(&#x27;.&#x27;);hexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, &#x27;/&#x27;, 1) + 1; else var beginPos = getPosition(link, &#x27;/&#x27;, 3) + 1; // In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;. var endPos = link.lastIndexOf(&#x27;/&#x27;) + 1; link = link.substring(beginPos, endPos); var toprocess = [&#x27;excerpt&#x27;, &#x27;more&#x27;, &#x27;content&#x27;]; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $(&#x27;img&#x27;).each(function()&#123; if ($(this).attr(&#x27;src&#x27;))&#123; // For windows style path, we replace &#x27;\\&#x27; to &#x27;/&#x27;. var src = $(this).attr(&#x27;src&#x27;).replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); if(!/http[s]*.*|\\/\\/.*/.test(src) &amp;&amp; !/^\\s*\\//.test(src)) &#123; // For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed. // In addition, to support multi-level local directory. var linkArray = link.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27;; &#125;); var srcArray = src.split(&#x27;/&#x27;).filter(function(elem)&#123; return elem != &#x27;&#x27; &amp;&amp; elem != &#x27;.&#x27;; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join(&#x27;/&#x27;); $(this).attr(&#x27;src&#x27;, &quot;/&quot; + link + src); console.info&amp;&amp;console.info(&quot;update link as:--&gt;&quot;+&quot;/&quot; + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info(&quot;no src attr, skipped...&quot;); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 5.3. 修改工作目录下 _config.yml1post_asset_folder: true 5.4. 修改typora偏好配置 参考资料：Ericam 6. 集成Travis CI6.1. 配置 personal access token6.1.1. 生成 access token 6.1.2. 拷贝access token到记事本，保存以备用 6.2. 配置 Travis CI6.2.1. 将 Travis CI 添加到你的 GitHub 账户中 6.2.2. 前往 GitHub 的 Applications settings，配置 Travis CI 权限，使其能够访问你的 repository 6.2.3. 将Github生成的 personal access token添加到travis中 6.3. 配置 .travis.yml6.3.1. 工作目录下新建 .travis.yml1234567891011121314151617181920212223242526272829303132333435363738394041# 指定构建环境是Node.js，当前版本是稳定版anguage: node_jsnode_js: stable# 设置钩子只检测blog-source分支的push变动branches: only: - main# 设置缓存文件cache: directories: - node_modules#在构建之前安装hexo环境和主题，这里的主题就是原来修改过的主题，我将其托管到另一个github仓库，直接clone就行，否则每次都是新的主题，要重新设置。before_install: - npm install -g hexo-cli#安装git插件和搜索功能插件install: - npm install - npm install hexo-deployer-git --save - npm install hexo-generator-searchdb --save - npm install hexo-asset-image --save# 执行清缓存，生成网页操作# 将 5.2 中的index.js 拷贝到imagedeal中script: - rm -rf ./node_modules/hexo-asset-image/index.js - cp ./imagedeal/index.js ./node_modules/hexo-asset-image - hexo clean - hexo generate# 设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署after_script: - git config user.name &quot;yangqinglei26&quot; - git config user.email &quot;dandetionyang@163.com&quot; # 替换同目录下的_config.yml文件中gh_token字符串为刚才在6.2.3中travis配置的变量，注意此处sed命令用了双引号。单引号无效！ - sed -i &quot;s/gh_token/$&#123;GH_TOKEN&#125;/g&quot; ./_config.yml - hexo deploy 6.3.2. 修改 _config.yml 6.4. 提交到github，并测试6.4.1. 删除 themes\\ayer 下多余的文件,不然主题配置会被覆盖 6.4.2. 提交并测试123456# 清空分支下所有文件git init git add .git commit -m &quot;初始化仓库&quot;git remote add origin https://github.com/yangqinglei26/yangtest.gitgit push -u origin master:main 7. 常用命令7.1. 新建相关 hexo new 1hexo new page -p 生活/买车 &quot;买车&quot; 1hexo new page manage 1hexo new page -p test 12# 默认使用 _config.yml 中的 default_layout 参数代替hexo new -p python/python &quot;python&quot; 1hexo new &quot;python&quot; Front-matter 参数 描述 默认值 layout 布局 config.default_layout title 标题 文章的文件名 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 excerpt Page excerpt in plain text. Use this plugin to format the text disableNunjucks Disable rendering of Nunjucks tag &#123;&#123; &#125;&#125;/&#123;% %&#125; and tag plugins when enabled lang Set the language to override auto-detection Inherited from _config.yml","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"hexo","slug":"java/hexo","permalink":"https://yangqinglei26.github.io/categories/java/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://yangqinglei26.github.io/tags/hexo/"}]},{"title":"Git","slug":"java/Git","date":"2021-05-31T02:24:06.000Z","updated":"2022-08-02T09:14:32.312Z","comments":true,"path":"2021/05/31/java/Git/","link":"","permalink":"https://yangqinglei26.github.io/2021/05/31/java/Git/","excerpt":"","text":"1. Git是什么 svn是集中化的版本控制系统，git是分布式版本控制系统 git直接记录快照，而非差异比较 近乎所有的操作都是本地执行 2. 基本操作 Git基本操作: https://www.runoob.com/git/git-basic-operations.html 2.1. 使用当前目录作为Git仓库12345678910111213进入该目录，右键进入git命令行模式#添加版本库git init#将本地文件添加到暂存区git add . # 将文件提交到版本库git commit -m &quot;注释&quot; #添加一个远程 Git 仓库，同时指定一个可以引用的简写origingit remote add origin https://gitee.com/yangqinglei26/study-notes.git #将本地版本库推送到远程版本库进行合并git push -u origin master # 显示远程仓库git remote -v 2.2. 记录每次更新到仓库123456#查看文件状态git status #文件状态从untracked变为staged，文件被添加到暂存区git add #查看暂存前后的变化git diff 2.3. 忽略文件 文件 .gitignore 的格式规范如下： 12345所有空行或者以 # 开头的行都会被 Git 忽略。可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。匹配模式可以以（/）开头防止递归。匹配模式可以以（/）结尾指定目录。要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。 3. 分支管理 Git分支管理策略: https://www.ruanyifeng.com/blog/2012/07/git.html 3.1. 创建合并分支12345678910111213141516#查看当前分支git branch #创建分支git branch dev#切换分支git checkout dev#创建并切换到一个分支里面git checkout -b dev#查看记录git log --pretty=oneline#合并记录,出现fast-forward就是快速合并git merge dev#执行正常合并，在Master分支上生成一个新节点git merge --no-ff dev#合并之后，就可以删除dev分支git checkout -d dev 3.2. 解决冲突 在不同分支上，都编辑了同一个文件，这时候合并，会出现冲突。解决方法：手动进行合并，在code文件中。然后在进行add和commit操作 软件开发中，遇到bug就像是家常便饭。当遇到bug的时候，每一个bug都要用过临时的分支来修复，修复后在合并分支，然后将临时分支删除。当你正在做某项任务的时候，临时有个紧急的任务，修复bug，但是你的代码没有写完，不能提交，可以通过下面的命令进行存储，等你修复完成之后，可以继续做。 123456#存储工作现场git stash#查看存储工作现场git stash list#恢复存储工作现场git stash pop 4. 查看提交历史5. 标签管理6. 服务器搭建7. 扩展7.1. SSH配置7.1.1. 检测SSH配置情况12345# 进入ssh目录cd ~/.ssh# 查看是否有id_rsa id_rsa.pub ls# 如果没有id_rsa id_rsa.pub ，进入第2步 7.1.2. 配置SSH7.1.2.1. 查询是否配置了全局参数1git config --global --list 如果未配置，执行以下命令： 1234# git config --global user.name &quot;这里换上你的用户名&quot;git config --global user.name &quot;yangqinglei26&quot;# git config --global user.email &quot;这里换上你的邮箱&quot;git config --global user.email &quot;dandetionyang@163.com&quot; 7.1.2.2. 生成公钥1ssh-keygen -o 执行命令后需要进行3次或4次确认： 确认秘钥的保存路径（如果不需要改路径则直接回车）；如果上一步置顶的保存路径下已经有秘钥文件，则需要确认是否覆盖（如果之前的秘钥不再需要则直接回车覆盖，如需要则手动拷贝到其他目录后再覆盖）；创建密码（如果不需要密码则直接回车）；确认密码；执行过程如下图： 7.1.2.3. 查看公钥1cat ~/.ssh/id_rsa.pub 7.1.2.4. 复制公钥到github 参考资料：Git官方文档 8. GitTalk使用 帮助手册：https://github.com/gitalk/gitalk/blob/master/readme-cn.md 8.1. 我们选取其中一种方式做说明 8.1.1. 获取owner、repo 参考资料： github 接口文档 gittalk会根据输入的参数去调用github接口，查询对应的issue 1https://api.github.com/repos/&#123;owner&#125;/&#123;repo&#125;/issues 8.1.2. 生成clientID、clientSecret 8.1.3. 参考12345clientID: 129f2c758bba8433d4c8clientSecret: 20a29f0beeec62e28c7b829941fac54793a99f3crepo: yangqinglei26owner: yangtestadmin: [yangqinglei26]","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"git","slug":"java/git","permalink":"https://yangqinglei26.github.io/categories/java/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yangqinglei26.github.io/tags/git/"}]},{"title":"netty","slug":"java/netty","date":"2021-05-29T11:24:06.000Z","updated":"2022-08-02T09:14:32.372Z","comments":true,"path":"2021/05/29/java/netty/","link":"","permalink":"https://yangqinglei26.github.io/2021/05/29/java/netty/","excerpt":"","text":"TCP/IP协议 TCP相关 socket原理 单服务器最大tcp连接数及调优汇总 分析单机最大长连接数 IO多路复用机制详解 io相关 Reactor详解 Reactor模式 理解高性能网络模型 netty相关 面试相关 1. 线程模型2. 核心组件3. 零拷贝 彻底搞懂Netty高性能之零拷贝 Netty的接收和发送ByteBuffer使用直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用JVM的堆内存进Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于使用直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 Netty的文件传输调用FileRegion包装的transferTo方法，可以直接将文件缓冲区的数据发送到目标Channel，避免通过循环write方式导致的内存拷贝问题。 Netty提供CompositeByteBuf类, 可以将多个ByteBuf合并为一个逻辑上的ByteBuf, 避免了各个ByteBuf之间的拷贝。 通过wrap操作, 我们可以将byte[]数组、ByteBuf、ByteBuffer等包装成一个Netty ByteBuf对象, 进而避免拷贝操作。 ByteBuf支持slice操作，可以将ByteBuf分解为多个共享同一个存储区域的ByteBuf, 避免内存的拷贝。 4. TCP粘包/拆包 [Netty中粘包和拆包的解决方案] Netty解决粘包和拆包问题的四种方案 5. 编码和解码6. 多协议7. 心跳 Netty实现心跳机制与断线重连","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"消息队列","slug":"java/消息队列","permalink":"https://yangqinglei26.github.io/categories/java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"消息队列","slug":"消息队列","permalink":"https://yangqinglei26.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://yangqinglei26.github.io/tags/rabbitmq/"}]},{"title":"Java","slug":"java/Java","date":"2021-05-28T11:24:06.000Z","updated":"2021-06-01T11:24:06.000Z","comments":true,"path":"2021/05/28/java/Java/","link":"","permalink":"https://yangqinglei26.github.io/2021/05/28/java/Java/","excerpt":"","text":"1. IO和NIO2. 多线程 Java Thread 的使用 Thread的join()方法 Java终止线程的三种方式 2.1. 创建线程2.1.1. 实现Runnable接口 推进使用：方便同一个对象被多个线程使用 1new Thread(Runnable 实现).start() 2.1.2. 继承Thread2.1.3. 实现Callable接口1234567实现Callable接口，需要返回值类型重写call方法，需要抛出异常创建目标对象创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);提交执行：Future&lt;Boolean&gt; result1 = ser.submit(t1);获取结果：boolean r1 = result1.get()关闭服务：ser.shutdownNow() 2.2. 停止线程2.2.1. 设置一个标志位1publ 2.3. 礼让线程 yield() 礼让线程，让当前正在执行的线程暂停，但不阻塞 将线程从运行状态转为就绪状态 让cpu重新调度，礼让不一定成功！看cpu心情 2.4. 强制执行线程 join() 2.5. 线程优先级 priority(1-10) 先设置优先级，再start() 2.6. 守护线程2.7. 线程同步 队列+锁 synchronized lock 2.8. 线程通信 生产者和消费者问题 synchronized while 防止虚假唤醒 wait()、notifyall() 2.8.1. 管程法 缓冲池 2.8.2. 信号灯法 标志位 2.9. 线程池3. 注解和反射4. JUC 参考资料1 参考资料2 ThreadLocal Java中的ThreadLocal详解 多个 THREADLOCAL 在 THREAD 中的 THREADLOCALS 里是怎么存储的 Java并发编程之happens-before和as-if-serial语义 java并发 4.1. wait和sleep的区别 来自不同的类 wait =&gt; object sleep =&gt; Thread 锁的释放 wait 会释放锁，sleep 不会释放 使用范围 wait 在 synchronized 中使用 4.2. Lock锁4.2.1. ReentrantLock 默认非公平锁 必须成对出现 示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ReentrantLockTest &#123; public static void main(String[] args) &#123; Mycache mycache = new Mycache(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 2; j++)&#123; try &#123; mycache.put(Thread.currentThread().getName()+&quot;:&quot;+j,&quot;toy&quot;+j); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;thread&quot;+i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 2; j++)&#123; mycache.get(Thread.currentThread().getName()+&quot;:&quot;+j); &#125; &#125;,&quot;thread&quot;+i).start(); &#125; &#125; static class Mycache&#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); ReentrantLock lock = new ReentrantLock(); public void put(String key,String value) throws InterruptedException &#123; lock.lock(); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;开始写入&quot;); map.put(key,value); TimeUnit.SECONDS.sleep(2); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;退出写入&quot;); lock.unlock(); &#125; public String get(String key)&#123; lock.lock(); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;开始读取&quot;); String value = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+value); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;退出读取&quot;); lock.unlock(); return value; &#125; &#125;&#125; 执行结果： 123456789101112131415161718192021222324252627282930thread0:开始写入thread0:退出写入thread1:开始写入thread1:退出写入thread1:开始写入thread1:退出写入thread2:开始写入thread2:退出写入thread0:开始读取thread0:toy0thread0:退出读取thread0:开始读取thread0:nullthread0:退出读取thread1:开始读取thread1:toy0thread1:退出读取thread1:开始读取thread1:toy1thread1:退出读取thread2:开始读取thread2:toy0thread2:退出读取thread2:开始读取thread2:nullthread2:退出读取thread0:开始写入thread0:退出写入thread2:开始写入thread2:退出写入 4.2.2. synchronized 和 lock 的区别 深入分析synchronized的实现原理 JAVA锁的膨胀过程 序号 synchronized lock 1 内置的java关键字 java接口 2 无法获取锁的状态 可以获取锁的状态 3 会自动释放锁 手动释放锁 4 线程阻塞时，其它线程会一直等待 可以主动尝试获取锁 5 非公平锁，不可以中断 可以自定义 6 适合锁少量的同步代码 适合锁大量的同步代码 4.2.3. Condition await() 、signal() 4.2.4. 八锁现象synchronized 锁的对象 方法的调用者 class类模板（static） 4.3. 集合相关 4.3.1. ArrayList并发下 ArrayList 会抛出 ConcurrentModificationExecptin ，解决办法： new Vector() 123456789101112131415// Vector.classpublic void add(int index, E element) &#123; insertElementAt(element, index);&#125;public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + &quot; &gt; &quot; + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++;&#125; Collections.synchronizedList(new ArrayList()) new CopyOnWriteArrayList&lt;&gt;() 读写分离 123456789101112131415// CopyOnWriteArrayList.classpublic boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 4.3.2. HashSet 底层 12345678// HashSet.classprivate static final Object PRESENT = new Object();public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; 并发下 HashSet 会抛出 ConcurrentModificationExecptin ，解决办法： Collections.synchronizedSet(new HashSet ()) new CopyOnWriteArraySet() 4.3.3. HashMap并发下 HashMap 会抛出 ConcurrentModificationExecptin ，解决办法： Collections.synchronizedMap(new HashMap ()) new ConcurrentHashMap() 4.4. Callable 调用 12345new Thread(new FutureTask(new Callable() &#123; public Object call() throws Exception &#123; return null; &#125;&#125;)).start(); 1234567891011121314151617181920212223public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask task = new FutureTask(new Callable() &#123; public String call() throws InterruptedException &#123; if(Thread.currentThread().getName().equals(&quot;A1&quot;))&#123; Thread.sleep(1000); &#125; return Thread.currentThread().getName() +&quot; do working&quot;; &#125; &#125;); new Thread(task,&quot;A1&quot;).start(); // task.get 会阻塞线程 String status = (String) task.get(); System.out.println(status); // call 只会被执行一次 new Thread(task,&quot;A2&quot;).start(); status = (String) task.get(); System.out.println(status); System.out.println(Thread.currentThread().getName()); &#125;&#125; 结果为： 123A1 do workingA1 do workingmain 4.5. CountDownLatch（倒计时弹簧锁）1234567891011121314151617181920212223public class CountDownLatchTest &#123; public static void main(String[] args) &#123; CountDownLatch latch = new CountDownLatch(5); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; synchronized (CountDownLatchTest.class) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; +&quot;进入等待&quot; + (latch.getCount() == 0 ?&quot;&quot;: latch.getCount())); latch.countDown(); &#125; try &#123; latch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; +&quot;结束等待&quot; ); &#125;,&quot;cousumer&quot;+i).start(); &#125; &#125;&#125; 执行结果： 1234567891011121314151617181920cousumer0:进入等待5cousumer4:进入等待4cousumer5:进入等待3cousumer3:进入等待2cousumer2:进入等待1cousumer2:结束等待cousumer4:结束等待cousumer1:进入等待cousumer3:结束等待cousumer0:结束等待cousumer5:结束等待cousumer1:结束等待cousumer8:进入等待cousumer8:结束等待cousumer6:进入等待cousumer6:结束等待cousumer9:进入等待cousumer9:结束等待cousumer7:进入等待cousumer7:结束等待 4.6. CyclicBarrier(循环阻塞)1234567891011121314151617181920212223242526public class CyclicBarrierTest &#123; public static void main(String[] args) &#123; int num = 3; CyclicBarrier cyclicBarrier = new CyclicBarrier(num); for (int i = 0; i &lt; 9; i++) &#123; new Thread(()-&gt;&#123; synchronized (CountDownLatchTest.class) &#123; System.out.println( Thread.currentThread().getName() + &quot;:&quot; + &quot;进入等待&quot; + cyclicBarrier.getNumberWaiting() ); &#125; try &#123; // 计数 + 等待 cyclicBarrier.await(); &#125; catch (BrokenBarrierException | InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + &quot;:&quot; +&quot;结束等待&quot; ); &#125;,&quot;cousumer&quot;+i).start(); &#125; &#125;&#125; 执行结果 123456789101112131415161718cousumer0:进入等待0cousumer1:进入等待1cousumer3:进入等待2cousumer3:结束等待cousumer2:进入等待0cousumer1:结束等待cousumer0:结束等待cousumer4:进入等待1cousumer5:进入等待2cousumer6:进入等待0cousumer4:结束等待cousumer2:结束等待cousumer5:结束等待cousumer7:进入等待1cousumer8:进入等待2cousumer8:结束等待cousumer6:结束等待cousumer7:结束等待 4.7. Semaphore(信号量)1234567891011121314151617181920212223public class SemaphoreTest &#123; public static void main(String[] args)&#123; Semaphore semaphore = new Semaphore(3); for (int i = 0; i &lt; 10; i++) &#123; new Thread(()-&gt;&#123; try &#123; semaphore.acquire(); System.out.println(Thread.currentThread().getName() + &quot;:&quot; + &quot;开始任务&quot;); TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName() + &quot;:&quot; + &quot;执行结束&quot; ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; semaphore.release(); &#125; &#125;,&quot;cousumer&quot;+i).start(); &#125; &#125;&#125; 执行结果： 1234567891011121314151617181920cousumer1:开始任务cousumer2:开始任务cousumer0:开始任务cousumer0:执行结束cousumer1:执行结束cousumer2:执行结束cousumer4:开始任务cousumer5:开始任务cousumer3:开始任务cousumer4:执行结束cousumer3:执行结束cousumer6:开始任务cousumer5:执行结束cousumer7:开始任务cousumer8:开始任务cousumer8:执行结束cousumer7:执行结束cousumer6:执行结束cousumer9:开始任务cousumer9:执行结束 只有获取到Semaphore才会开始工作 4.8. ReadWriteLock1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; Mycache mycache = new Mycache(); for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 2; j++)&#123; try &#123; mycache.put(Thread.currentThread().getName()+&quot;:&quot;+j,&quot;toy&quot;+j); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;thread&quot;+i).start(); &#125; for (int i = 0; i &lt; 3; i++) &#123; new Thread(()-&gt;&#123; for (int j = 0; j &lt; 2; j++)&#123; try &#123; mycache.get(Thread.currentThread().getName()+&quot;:&quot;+j); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;,&quot;thread&quot;+i).start(); &#125; &#125; static class Mycache&#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); public void put(String key,String value) throws InterruptedException &#123; lock.writeLock().lock(); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;开始写入&quot;); map.put(key,value); TimeUnit.SECONDS.sleep(1); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;退出写入&quot;); lock.writeLock().unlock(); &#125; public String get(String key) throws InterruptedException &#123; lock.readLock().lock(); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;开始读取&quot;); String value = map.get(key); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+value); System.out.println(Thread.currentThread().getName()+&quot;:&quot;+&quot;退出读取&quot;); lock.readLock().unlock(); return value; &#125; &#125;&#125; 执行结果： 123456789101112131415161718192021222324252627282930thread0:开始写入thread0:退出写入thread0:开始写入thread0:退出写入thread2:开始写入thread2:退出写入thread2:开始写入thread2:退出写入thread1:开始写入thread1:退出写入thread1:开始写入thread1:退出写入thread0:开始读取thread0:toy0thread0:退出读取thread0:开始读取thread2:开始读取thread2:toy0thread2:退出读取thread0:toy1thread0:退出读取thread1:开始读取thread1:toy0thread1:退出读取thread2:开始读取thread2:toy1thread2:退出读取thread1:开始读取thread1:toy1thread1:退出读取 所有写线程结束，才会进入读线程。读线程读取时，并没有锁定代码块。 4.9. BlockingQueue 4.9.1. ArrayBlockingQueue 抛出异常 特殊值 阻塞 超时 插入 add(e) offer(e) put(e) offer(e, time, unit) 移除 remove() poll() take() poll(time, unit) 检查 element() peek() 不可用 不可用 4.9.2. SynchronousQueue4.10. Executors4.10.1. 三种创建方式（不采用）4.10.2. ThreadPoolExecutor 七大参数 123456789101112131415161718192021222324252627282930313233343536/** * Creates a new &#123;@code ThreadPoolExecutor&#125; with the given initial * parameters. * * @param corePoolSize the number of threads to keep in the pool, even * if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is set * @param maximumPoolSize the maximum number of threads to allow in the * pool * @param keepAliveTime when the number of threads is greater than * the core, this is the maximum time that excess idle threads * will wait for new tasks before terminating. * @param unit the time unit for the &#123;@code keepAliveTime&#125; argument * @param workQueue the queue to use for holding tasks before they are * executed. This queue will hold only the &#123;@code Runnable&#125; * tasks submitted by the &#123;@code execute&#125; method. * @param threadFactory the factory to use when the executor * creates a new thread * @param handler the handler to use when execution is blocked * because the thread bounds and queue capacities are reached * @throws IllegalArgumentException if one of the following holds:&lt;br&gt; * &#123;@code corePoolSize &lt; 0&#125;&lt;br&gt; * &#123;@code keepAliveTime &lt; 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt;= 0&#125;&lt;br&gt; * &#123;@code maximumPoolSize &lt; corePoolSize&#125; * @throws NullPointerException if &#123;@code workQueue&#125; * or &#123;@code threadFactory&#125; or &#123;@code handler&#125; is null */public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; &#125; cpu密集型 IO密集型 4.11. 四大函数式接口4.12. Stream 流式计算4.13. ForkJoin ForkJoin 4.14. 异步回调 4.15. JMM 内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个： 保证特定操作的顺序 保证某些变量的内存可见性（利用该特性实现volatile的内存可见性） 4.16. volatile JMM角度详解Volatile Java volatile关键字 volatile 是java虚拟机提供的轻量级的同步机制 保证可见性 不保证原子性 原子类 禁止指令重排 4.17. 单例模式 DCL懒汉式 1 枚举 4.18. CAS ABA 问题 AtomicInteger AtomicStampedReference 4.19. 各种锁 不可不说的Java“锁”事 4.19.1. 公平锁、非公平锁4.19.2. 可重入锁4.19.3. 自旋锁4.19.4. 死锁 死锁排查 程序员面试宝典4.27版 5. JVM 知识架构图 JVM内存图 字符串常量池 动态链接 订单秒杀jvm调优案例 美团JVM相关文档 123456789101112131415161718/** * @Description: 字面量测试 * @Author: yql * @Date: 2021/6/8 18:43 * @Version: 1.0 */public class LiteralTest &#123; public static String s = &quot;Hello&quot;; public static int anInt = 25; public int bnInt = 30; public Integer cnInt = 50; public static final int dnInt = 70; int m = 100; static &#123; anInt = 90; &#125;&#125; 12# 查看编译后类信息javap -verbose LiteralTest.class 6. Java8 java8特性 6.1. 函数式接口 函数式接口 定义：任何接口，如果只包含唯一一个抽象方法，那么它就是函数式接口 可以用lamada表达式代替匿名内部类来实现 6.1.1 Predicates1234@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; boolean test(T t);&#125; 6.1.2 Functions1234@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; R apply(T t);&#125; 6.1.3 Suppliers1234@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; T get();&#125; 6.1.4 Consumers1234@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; void accept(T t);&#125; 6.2. Lamada表达式 Lambda 表达式 6.3. 方法引用 方法引用 6.4. Stream Stream 6.5. 默认方法 默认方法 6.6. Optional 类 Optional 类 6.7. 日期时间 新的日期时间 API","categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"jvm","slug":"java/jvm","permalink":"https://yangqinglei26.github.io/categories/java/jvm/"},{"name":"juc","slug":"java/jvm/juc","permalink":"https://yangqinglei26.github.io/categories/java/jvm/juc/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"jvm","slug":"jvm","permalink":"https://yangqinglei26.github.io/tags/jvm/"},{"name":"juc","slug":"juc","permalink":"https://yangqinglei26.github.io/tags/juc/"}]}],"categories":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/categories/java/"},{"name":"服务器","slug":"java/服务器","permalink":"https://yangqinglei26.github.io/categories/java/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Mybatis","slug":"java/Mybatis","permalink":"https://yangqinglei26.github.io/categories/java/Mybatis/"},{"name":"数据库","slug":"java/Mybatis/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mybatis/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络相关","slug":"java/网络相关","permalink":"https://yangqinglei26.github.io/categories/java/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"},{"name":"zookeeper","slug":"java/zookeeper","permalink":"https://yangqinglei26.github.io/categories/java/zookeeper/"},{"name":"分布式","slug":"java/zookeeper/分布式","permalink":"https://yangqinglei26.github.io/categories/java/zookeeper/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"linux","slug":"linux","permalink":"https://yangqinglei26.github.io/categories/linux/"},{"name":"分布式","slug":"java/分布式","permalink":"https://yangqinglei26.github.io/categories/java/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"nosql","slug":"java/nosql","permalink":"https://yangqinglei26.github.io/categories/java/nosql/"},{"name":"运维","slug":"java/运维","permalink":"https://yangqinglei26.github.io/categories/java/%E8%BF%90%E7%BB%B4/"},{"name":"spring","slug":"java/spring","permalink":"https://yangqinglei26.github.io/categories/java/spring/"},{"name":"springcloud","slug":"java/spring/springcloud","permalink":"https://yangqinglei26.github.io/categories/java/spring/springcloud/"},{"name":"工作流","slug":"java/工作流","permalink":"https://yangqinglei26.github.io/categories/java/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"消息队列","slug":"java/消息队列","permalink":"https://yangqinglei26.github.io/categories/java/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"缓存","slug":"java/缓存","permalink":"https://yangqinglei26.github.io/categories/java/%E7%BC%93%E5%AD%98/"},{"name":"springboot","slug":"java/spring/springboot","permalink":"https://yangqinglei26.github.io/categories/java/spring/springboot/"},{"name":"数据库","slug":"java/数据库","permalink":"https://yangqinglei26.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式数据处理","slug":"java/数据库/分布式数据处理","permalink":"https://yangqinglei26.github.io/categories/java/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Mycat","slug":"java/Mycat","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/"},{"name":"数据库","slug":"java/Mycat/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"分布式数据处理","slug":"java/Mycat/数据库/分布式数据处理","permalink":"https://yangqinglei26.github.io/categories/java/Mycat/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"Mysql","slug":"java/Mysql","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/"},{"name":"数据库","slug":"java/Mysql/数据库","permalink":"https://yangqinglei26.github.io/categories/java/Mysql/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"设计模式","slug":"java/设计模式","permalink":"https://yangqinglei26.github.io/categories/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"管理","slug":"管理","permalink":"https://yangqinglei26.github.io/categories/%E7%AE%A1%E7%90%86/"},{"name":"生活","slug":"生活","permalink":"https://yangqinglei26.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"hexo","slug":"java/hexo","permalink":"https://yangqinglei26.github.io/categories/java/hexo/"},{"name":"git","slug":"java/git","permalink":"https://yangqinglei26.github.io/categories/java/git/"},{"name":"jvm","slug":"java/jvm","permalink":"https://yangqinglei26.github.io/categories/java/jvm/"},{"name":"juc","slug":"java/jvm/juc","permalink":"https://yangqinglei26.github.io/categories/java/jvm/juc/"}],"tags":[{"name":"java","slug":"java","permalink":"https://yangqinglei26.github.io/tags/java/"},{"name":"服务器","slug":"服务器","permalink":"https://yangqinglei26.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"nginx","slug":"nginx","permalink":"https://yangqinglei26.github.io/tags/nginx/"},{"name":"Mybatis","slug":"Mybatis","permalink":"https://yangqinglei26.github.io/tags/Mybatis/"},{"name":"数据库","slug":"数据库","permalink":"https://yangqinglei26.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"网络相关","slug":"网络相关","permalink":"https://yangqinglei26.github.io/tags/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"},{"name":"zookeeper","slug":"zookeeper","permalink":"https://yangqinglei26.github.io/tags/zookeeper/"},{"name":"分布式","slug":"分布式","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"linux","slug":"linux","permalink":"https://yangqinglei26.github.io/tags/linux/"},{"name":"elk","slug":"elk","permalink":"https://yangqinglei26.github.io/tags/elk/"},{"name":"nosql","slug":"nosql","permalink":"https://yangqinglei26.github.io/tags/nosql/"},{"name":"docker","slug":"docker","permalink":"https://yangqinglei26.github.io/tags/docker/"},{"name":"运维","slug":"运维","permalink":"https://yangqinglei26.github.io/tags/%E8%BF%90%E7%BB%B4/"},{"name":"spring","slug":"spring","permalink":"https://yangqinglei26.github.io/tags/spring/"},{"name":"springcloud","slug":"springcloud","permalink":"https://yangqinglei26.github.io/tags/springcloud/"},{"name":"activiti","slug":"activiti","permalink":"https://yangqinglei26.github.io/tags/activiti/"},{"name":"工作流","slug":"工作流","permalink":"https://yangqinglei26.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%B5%81/"},{"name":"消息队列","slug":"消息队列","permalink":"https://yangqinglei26.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"rabbitmq","slug":"rabbitmq","permalink":"https://yangqinglei26.github.io/tags/rabbitmq/"},{"name":"redis","slug":"redis","permalink":"https://yangqinglei26.github.io/tags/redis/"},{"name":"缓存","slug":"缓存","permalink":"https://yangqinglei26.github.io/tags/%E7%BC%93%E5%AD%98/"},{"name":"springboot","slug":"springboot","permalink":"https://yangqinglei26.github.io/tags/springboot/"},{"name":"分布式数据处理","slug":"分布式数据处理","permalink":"https://yangqinglei26.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"},{"name":"ShardingSphere","slug":"ShardingSphere","permalink":"https://yangqinglei26.github.io/tags/ShardingSphere/"},{"name":"Mycat","slug":"Mycat","permalink":"https://yangqinglei26.github.io/tags/Mycat/"},{"name":"Mysql","slug":"Mysql","permalink":"https://yangqinglei26.github.io/tags/Mysql/"},{"name":"设计模式","slug":"设计模式","permalink":"https://yangqinglei26.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"管理","slug":"管理","permalink":"https://yangqinglei26.github.io/tags/%E7%AE%A1%E7%90%86/"},{"name":"买车","slug":"买车","permalink":"https://yangqinglei26.github.io/tags/%E4%B9%B0%E8%BD%A6/"},{"name":"生活","slug":"生活","permalink":"https://yangqinglei26.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"hexo","slug":"hexo","permalink":"https://yangqinglei26.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://yangqinglei26.github.io/tags/git/"},{"name":"jvm","slug":"jvm","permalink":"https://yangqinglei26.github.io/tags/jvm/"},{"name":"juc","slug":"juc","permalink":"https://yangqinglei26.github.io/tags/juc/"}]}